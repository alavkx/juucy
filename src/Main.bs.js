// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");

function fromString(str) {
  switch (str) {
    case "(" :
        return /* OpenParens */2;
    case ")" :
        return /* CloseParens */3;
    case "=" :
        return /* Equals */15;
    case "=>" :
        return /* Arrow */5;
    case "@entry" :
        return {
                TAG: /* SpecialEvent */1,
                _0: /* Entry */0
              };
    case "@exit" :
        return {
                TAG: /* SpecialEvent */1,
                _0: /* Exit */1
              };
    case "action" :
        return /* Action */13;
    case "assign" :
        return /* Assign */11;
    case "delay" :
        return /* Delay */9;
    case "guard" :
        return /* Guard */14;
    case "initial" :
        return /* Initial */6;
    case "invoke" :
        return /* Invoke */10;
    case "machine" :
        return /* Machine */7;
    case "on" :
        return /* On */12;
    case "send" :
        return /* Send */17;
    case "spawn" :
        return /* Spawn */16;
    case "state" :
        return /* State */4;
    case "use" :
        return /* Use */8;
    case "{" :
        return /* OpenCurly */0;
    case "" :
    case "!" :
    case "\"" :
    case "#" :
    case "$" :
    case "%" :
    case "&" :
    case "'" :
    case "*" :
    case "+" :
    case "," :
    case "-" :
    case "." :
    case "/" :
    case ":" :
    case ";" :
    case "<" :
    case "?" :
    case "@" :
    case "[" :
    case "\\" :
    case "]" :
    case "^" :
    case "|" :
        return {
                TAG: /* Unexpected */5,
                _0: str
              };
    case "}" :
        return /* CloseCurly */1;
    default:
      return {
              TAG: /* Word */3,
              _0: str
            };
  }
}

function toString(token) {
  if (typeof token === "number") {
    switch (token) {
      case /* OpenCurly */0 :
          return "OpenCurly";
      case /* CloseCurly */1 :
          return "CloseCurly";
      case /* OpenParens */2 :
          return "OpenParens";
      case /* CloseParens */3 :
          return "CloseParens";
      case /* State */4 :
          return "State";
      case /* Arrow */5 :
          return "Arrow";
      case /* Initial */6 :
          return "Initial";
      case /* Machine */7 :
          return "Machine";
      case /* Use */8 :
          return "Use";
      case /* Delay */9 :
          return "Delay";
      case /* Invoke */10 :
          return "Invoke";
      case /* Assign */11 :
          return "Assign";
      case /* On */12 :
          return "On";
      case /* Action */13 :
          return "Action";
      case /* Guard */14 :
          return "Guard";
      case /* Equals */15 :
          return "Equals";
      case /* Spawn */16 :
          return "Spawn";
      case /* Send */17 :
          return "Send";
      
    }
  } else {
    switch (token.TAG | 0) {
      case /* Timeframe */0 :
          switch (token._0) {
            case /* Seconds */0 :
                return "Timeframe(S, " + String(token._1) + "]";
            case /* Milliseconds */1 :
                return "Timeframe(MS, " + String(token._1) + "]";
            case /* Minutes */2 :
                return "Timeframe(MIN, " + String(token._1) + "]";
            
          }
      case /* SpecialEvent */1 :
          return "SpecialEvent";
      case /* String */2 :
          return "String";
      case /* Word */3 :
          return "Word(" + token._0 + ")";
      case /* Symbol */4 :
          return "Symbol";
      case /* Unexpected */5 :
          return "Unexpected(" + token._0 + ")";
      
    }
  }
}

var Token = {
  fromString: fromString,
  toString: toString
};

function make(column, line, value) {
  return {
          value: value,
          line: line,
          column: column
        };
}

var PositionToken = {
  make: make
};

function make$1(source) {
  return {
          source: source,
          tokens: [],
          index: 0,
          wordOffset: 0,
          line: 1,
          column: 1
        };
}

function toWord(cursor) {
  return cursor.source.substr(cursor.index, cursor.wordOffset + 1 | 0);
}

function toCharacter(cursor) {
  return cursor.source.substr(cursor.index + cursor.wordOffset | 0, 1);
}

function trace(name, fn, cursor) {
  var res = Curry._1(fn, cursor);
  console.log("[" + name + "]");
  return res;
}

function trace2(name, fn, cursor, token) {
  var res = Curry._2(fn, cursor, token);
  console.log("[" + name + "] " + toString(token));
  console.log("Current character: " + toCharacter(cursor));
  console.log("Current word: " + toWord(cursor));
  console.log("index: " + String(cursor.index) + " â€” wordOffset: " + String(cursor.wordOffset));
  console.log("------------------------------------");
  return res;
}

function commitToken(param, param$1) {
  return trace2("commitToken", (function (cursor, token) {
                return {
                        source: cursor.source,
                        tokens: Belt_Array.concat(cursor.tokens, [{
                                value: token,
                                line: cursor.line,
                                column: cursor.column
                              }]),
                        index: (cursor.index + cursor.wordOffset | 0) + 1 | 0,
                        wordOffset: 0,
                        line: cursor.line,
                        column: (cursor.column + cursor.wordOffset | 0) + 1 | 0
                      };
              }), param, param$1);
}

function nextLine(param) {
  return trace("nextLine", (function (cursor) {
                return {
                        source: cursor.source,
                        tokens: cursor.tokens,
                        index: cursor.index + 1 | 0,
                        wordOffset: 0,
                        line: cursor.line + 1 | 0,
                        column: 1
                      };
              }), param);
}

function advance(param) {
  return trace("advance", (function (cursor) {
                return {
                        source: cursor.source,
                        tokens: cursor.tokens,
                        index: cursor.index + 1 | 0,
                        wordOffset: 0,
                        line: cursor.line,
                        column: cursor.column + 1 | 0
                      };
              }), param);
}

function lookahead(param) {
  return trace("lookahead", (function (cursor) {
                return {
                        source: cursor.source,
                        tokens: cursor.tokens,
                        index: cursor.index,
                        wordOffset: cursor.wordOffset + 1 | 0,
                        line: cursor.line,
                        column: cursor.column
                      };
              }), param);
}

var Cursor = {
  make: make$1,
  toWord: toWord,
  toCharacter: toCharacter,
  trace: trace,
  trace2: trace2,
  commitToken: commitToken,
  nextLine: nextLine,
  advance: advance,
  lookahead: lookahead
};

function alpha(str) {
  return /^[A-Z_]+$/i.test(str);
}

function alphanumeric(str) {
  return /^\w+$/.test(str);
}

function scanIdentifier(_cursor) {
  while(true) {
    var cursor = _cursor;
    if (!alphanumeric(toCharacter(lookahead(cursor)))) {
      return commitToken(cursor, fromString(toWord(cursor)));
    }
    _cursor = lookahead(cursor);
    continue ;
  };
}

function scan(_cursor) {
  while(true) {
    var cursor = _cursor;
    var lexeme = toCharacter(cursor);
    switch (lexeme) {
      case "" :
          return cursor.tokens;
      case "\n" :
      case "\r" :
          _cursor = nextLine(cursor);
          continue ;
      case "\t" :
      case " " :
          _cursor = advance(cursor);
          continue ;
      case "=" :
          var match = toCharacter(lookahead(cursor));
          if (match === ">") {
            _cursor = commitToken(lookahead(cursor), /* Arrow */5);
            continue ;
          }
          _cursor = commitToken(cursor, {
                TAG: /* Unexpected */5,
                _0: lexeme
              });
          continue ;
      default:
        if (alpha(lexeme)) {
          _cursor = scanIdentifier(cursor);
          continue ;
        }
        _cursor = commitToken(cursor, fromString(toWord(cursor)));
        continue ;
    }
  };
}

function report(line, where, message) {
  console.log("[line: " + line + "] Error " + where + ": " + message);
  
}

var input = "\n  state enabled {\n    toggle => disabled\n  }\n\n  initial state disabled {\n    toggle => enabled\n  }\n";

var output = scan(make$1(input));

console.log("-------------[Tokens]---------------");

console.log(output);

console.log("------------------------------------");

var debug = true;

exports.debug = debug;
exports.Token = Token;
exports.PositionToken = PositionToken;
exports.Cursor = Cursor;
exports.alpha = alpha;
exports.alphanumeric = alphanumeric;
exports.scanIdentifier = scanIdentifier;
exports.scan = scan;
exports.report = report;
exports.input = input;
exports.output = output;
/* output Not a pure module */
